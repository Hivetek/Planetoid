{
  "name": "emits",
  "version": "1.0.1",
  "description": "returns a function which will emit and parse the specified event",
  "main": "index.js",
  "scripts": {
    "test": "mocha --reporter spec --ui bdd test.js",
    "coverage": "istanbul cover node_modules/.bin/_mocha -- --reporter spec --ui bdd test.js",
    "test-travis": "istanbul cover node_modules/.bin/_mocha --report lcovonly -- --reporter spec --ui bdd test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/primus/emits"
  },
  "keywords": [
    "emits",
    "event",
    "parser",
    "eventemitter"
  ],
  "author": {
    "name": "Arnout Kazemier"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/primus/emits/issues"
  },
  "homepage": "https://github.com/primus/emits",
  "devDependencies": {
    "assume": "0.0.x",
    "istanbul": "0.3.x",
    "mocha": "1.21.x",
    "pre-commit": "0.0.x"
  },
  "readme": "# emits\n\n[![Build Status](https://travis-ci.org/primus/emits.svg?branch=master)](https://travis-ci.org/primus/emits)\n[![NPM version](https://badge.fury.io/js/emits.svg)](http://badge.fury.io/js/emits)\n[![Coverage Status](https://img.shields.io/coveralls/primus/emits.svg)](https://coveralls.io/r/primus/emits?branch=master)\n\n## Installation\n\nThis module is compatible with browserify and node.js and is therefor release\nthrough npm:\n\n```\nnpm install --save emits\n```\n\n## Usage\n\nIn all examples we assume that you've assigned the `emits` function to the\nprototype of your class. This class should inherit from an `EventEmitter` class\nwhich uses the `emit` function to emit events and the `listeners` method to list\nthe listeners for a given event. For example:\n\n```js\n'use strict';\n\nvar EventEmitter = require('events').EventEmitter\n  , emits = require('emits');\n\nfunction Example() {\n  EventEmitter.call(this);\n}\n\nrequire('util').inherits(Example, EventEmitter);\n\n//\n// You can directly assign the function to the prototype if you wish or store it\n// in a variable and then assign to the prototype. What pleases you more.\n//\nExample.prototype.emits = emits; // require('emits');\n\n//\n// Also initialize the example so we can use the assigned method.\n//\nvar example = new Example();\n```\n\nNow that we've setup our example code we can finally demonstrate the beauty of\nthis functionality. To create a function that emits `data` we can simply do:\n\n```js\nvar data = example.emits('data');\n```\n\nEvery time you invoke the `data()` function it will emit the `data` event with\nall the arguments you supplied. If you want \"curry\" some extra arguments you add\nthose after the event name:\n\n```js\nvar data = example.emits('data', 'foo');\n```\n\nNow when you call `data()` the `data` event will receive `foo` as first argument\nand the rest of the arguments would be the once that you've supplied the\n`data()` function.\n\nIf you supply a function as last argument we assume that this is an argument\nparser so you can modify arguments, prevent the emit of the event or just clear\nall supplied arguments (except for the once that are curried in).\n\n```js\nvar data = example.emits('data', function parser(arg) {\n  return 'bar';\n})\n```\n\nIn the example above we've have transformed the incoming argument to `bar`. So\nwhen call `data()` it will emit a `data` event with `bar` as only argument.\n\nTo prevent the emitting from happening you need to return the `parser` function\nthat you supplied. This is the only reliable way to determine if we need to\nprevent an emit:\n\n```js\nvar data = example.emits('data', function parser() {\n  return parser;\n});\n```\n\nIf you return `undefined` from parser we assume that no modification have been\nmade to the arguments and we should emit our received arguments. If `null` is\nreturned function we assume that all received arguments should be removed.\n\n### Patterns\n\nOne our most common patterns for this module is to proxy events from one\ninstance to another:\n\n```js\neventemitter.on('data', example.emits('data'));\n```\n\nBut also to re-format data so it becomes more usable. For example in the case of\nWebSockets we don't want to reference `evt.data` every single time we just want\nthe data, so we can parse the argument as following:\n\n```js\nvar ws = new WebSocket('wss://example.org/path');\nws.onmessage = example.emits('data', function parser(evt) {\n  return evt.data;\n});\n```\n\nIn the example above we will now emit the `data` event with a direct reference\nto `evt.data`. And as final example, you can also use it prevent events from\nbeing emitted.\n\n```js\nvar ws = new WebSocket('wss://example.org/path');\nws.onmessage = example.emits('data', function parser(evt) {\n  var data;\n\n  try { data = JSON.parse(evt.data); }\n  catch (e) { return parser; }\n\n  if ('object' !== typeof data || Array.isArray(data)) {\n    return parser;\n  }\n\n  return data;\n});\n```\n\nBy returning a reference to the parser we tell the emits function that we should\nprevent the emitting of the event. So the `data` event will only be fired if\nwe've received a valid JSON document from the server and it's an object.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "emits@1.0.1",
  "dist": {
    "shasum": "09168e2dd4bf4b112fdf6f81abf4810ac6c2dc94"
  },
  "_from": "emits@1.0.x",
  "_resolved": "https://registry.npmjs.org/emits/-/emits-1.0.1.tgz"
}
